import { NextRequest, NextResponse } from 'next/server';

interface TextEmbroideryRequest {
  text: string;
  shape: 'line' | 'circle';
  units: 'mm' | 'inches';
  lineLength?: number;
  circleRadius?: number;
  outputFormats: string[];
}

interface EmbroideryFile {
  format: string;
  content: string; // Base64 encoded file content
  filename: string;
}

export async function POST(request: NextRequest) {
  try {
    const body: TextEmbroideryRequest = await request.json();
    
    // Validate input
    if (!body.text || body.text.trim().length === 0) {
      return NextResponse.json(
        { error: 'Text content is required' },
        { status: 400 }
      );
    }

    if (!body.outputFormats || body.outputFormats.length === 0) {
      return NextResponse.json(
        { error: 'At least one output format is required' },
        { status: 400 }
      );
    }

    // Simulate processing time (in real implementation, this would call the Python worker)
    await new Promise(resolve => setTimeout(resolve, 2000));

    // Generate mock embroidery files for each requested format
    const files: EmbroideryFile[] = body.outputFormats.map(format => {
      const mockContent = generateMockEmbroideryFile(body.text, body.shape, format);
      return {
        format,
        content: btoa(mockContent), // Base64 encode
        filename: `embroidery-${Date.now()}.${format.toLowerCase()}`
      };
    });

    // Create a job record (in real implementation, this would go to database)
    const jobId = `text_${Date.now()}`;
    
    return NextResponse.json({
      success: true,
      jobId,
      files,
      message: `Successfully generated ${files.length} embroidery file(s) from text "${body.text}"`
    });

  } catch (error) {
    console.error('Text to embroidery error:', error);
    return NextResponse.json(
      { error: 'Failed to process text to embroidery' },
      { status: 500 }
    );
  }
}

function generateMockEmbroideryFile(text: string, shape: string, format: string): string {
  // This is a mock implementation - in reality, this would use libembroidery or similar
  const timestamp = new Date().toISOString();
  const mockHeader = `# Embroidery File Generated by EmbroideryForge
# Text: "${text}"
# Shape: ${shape}
# Format: ${format}
# Generated: ${timestamp}
# This is a mock file for testing purposes

`;
  
  // Generate mock stitch data based on text length and shape
  const stitchCount = text.length * 10; // Rough estimate
  let stitches = '';
  
  for (let i = 0; i < stitchCount; i++) {
    const x = Math.floor(Math.random() * 1000);
    const y = Math.floor(Math.random() * 1000);
    stitches += `${x},${y}\n`;
  }
  
  return mockHeader + stitches;
}
